#!/bin/sh
#| -*- mode:scheme; coding:utf-8; -*-
exec sagittarius $0 "$@"
|#
;;;; protoc-scm --- Code generation utility for r6rs-protobuf/Sagittarius
;;;; 
;;;; 	Copyright (C) 2015 Takashi Kato
;;;; 
;;;; This library is free software; you can redistribute it and/or
;;;; modify it under the terms of the GNU Lesser General Public
;;;; License as published by the Free Software Foundation; either
;;;; version 3 of the License, or (at your option) any later version.
;;;; 
;;;; This library is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;;;; Lesser General Public License for more details.
;;;; 
;;;; You should have received a copy of the GNU Lesser General Public
;;;; License along with this library; if not, write to the Free
;;;; Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
;;;; Boston, MA 02110-1301 USA

(import (rnrs)
	(getopt)
	(protobuf compile parse)
	(protobuf compile codegen)
	(protobuf compile resolve)
	(protobuf compile)
	(srfi :1))

(define default-package-name-transformer
  (protoc:naming-context-library-name protoc:default-naming-context))
;; generated singleton-libraries are separated by message names
;; and if package is specified, this is kinda incovenient to use
;; so create a library named ($package) and let it export all
;; bindings defined in the libraries.
(define (top-library package libraries)
  (define (gen-library package libraries)
    (let ((lib (default-package-name-transformer package))
	  (exports (map caddr libraries))
	  (names (map cadr libraries)))
      `(library ,lib
	   (export ,@(apply append (map cdr exports)))
	   (import ,@names))))
  (let ((name (protoc:package-name package)))
    (and name
	(gen-library package (filter (lambda (lib)
				       (let ((lib-name (cadr lib)))
					 (eq? (car lib-name)
					      (string->symbol name))))
				     libraries)))))

(define (append-top-libraries root libraries)
  ;; the root package doesn't have name. Thus we need to ignore
  (let loop ((packages (protoc:package-subpackages root)) (r '()))
    ;; we don't follow subsub packages
    (if (null? packages)
	;; the order of toplibrary doesn't matter
	(append libraries (filter values r))
	(loop (cdr packages)
	      (cons (top-library (car packages) libraries) r)))))

(define (write-libraries libraries standalone out)
  (when standalone
    (call-with-input-file standalone
      (lambda (in)
	(let loop ((line (get-line in)))
	  (unless (eof-object? line)
	    (put-string out line)
	    (newline out)
	    (loop (get-line in)))))))
  (newline out)
  (display ";; Generated by the protocol buffer compiler.  DO NOT EDIT!" out)
  (newline out)
  (for-each (lambda (l) (protoc:pretty-print l out)) libraries))

(define (usage)
  (print "protoc-scm [OPTIONS]")
  (print " Option:")
  (print " -i,--input-file: Specifying input file [Mandatory]")
  (print " -o,--output-file: Specifying output file. If this is omit, then")
  (print "   the result is printed in standard out.")
  (print " -t,--append-top: Append toplevel library.")
  (print " -s,--standalone: Add (protobuf private) library.")
  (print "   NOTE: this option makes the result library licence GPLv3")
  (exit -1))

(define (main args)
  (with-args (cdr args)
      ((in-file (#\i "input-file") #t (usage))
       (out-file (#\o "output-file") #t #f)
       (append-top (#\t "append-top") #f #f)
       (standalone (#\s "standalone") #t #f)
       (help (#\h "help") #f #f)
       . rest)
    (when (or help (not (null? rest))) (usage))
    (let ((proto (protoc:read-proto (open-input-file in-file)))
	)
      (let-values ((libs (protoc:generate-libraries proto)))
	(write-libraries (if append-top 
			     (append-top-libraries 
			      (protoc:proto-root-package proto)
			      libs)
			     libs)
			 standalone
			 (if out-file 
			     (open-file-output-port out-file 
			       (file-options no-fail)
			       (buffer-mode block)
			       (native-transcoder))
			     (current-output-port)))))))
